{"version":3,"file":"PathFinding.js","sourceRoot":"","sources":["../src/PathFinding.ts"],"names":[],"mappings":"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","sourcesContent":["import { Node } from './Node';\n\nexport enum Types {\n\tSTART = 's',\n\tEND = 'e',\n\tWALKABLE = 'w',\n\tNON_WALKABLE = 'nw',\n}\n\nexport interface WalkableTile {\n\ttype: number;\n\tweight?: number;\n}\n\ntype AllTypes = number | Types.START | Types.END | Types.NON_WALKABLE | undefined;\n\nexport enum Heuristic {\n\tMANHATTAN,\n\tDIAGONAL,\n}\n\nexport class PathFinding {\n\tprivate DEFAULT_DISTANCE: number = 10;\n\tprivate DIAGONAL_DISTANCE: number = 14;\n\n\tprivate heuristic: Heuristic = Heuristic.MANHATTAN;\n\tprivate allowDiagonal: boolean = false;\n\tprivate walkableTypes: (number | WalkableTile)[] = [];\n\tprivate start: number | { row: number; col: number };\n\tprivate end: number | { row: number; col: number };\n\n\tconstructor(options?: { heuristic: Heuristic; allowDiagonal?: boolean }) {\n\t\tif (options && options.heuristic) {\n\t\t\tthis.heuristic = options.heuristic;\n\t\t\tthis.allowDiagonal = options.allowDiagonal || false;\n\t\t}\n\t}\n\n\tpublic setWalkable(...args: (number | WalkableTile)[]) {\n\t\tthis.walkableTypes = this.walkableTypes.concat(...args).map((tileType: number | WalkableTile) => {\n\t\t\tif (this.isNumber(tileType as number)) {\n\t\t\t\treturn { type: tileType as number, weight: 1 };\n\t\t\t} else {\n\t\t\t\tconst walkableData: WalkableTile = {\n\t\t\t\t\ttype: (tileType as WalkableTile).type,\n\t\t\t\t\tweight: (tileType as WalkableTile).weight ? (tileType as WalkableTile).weight : 1,\n\t\t\t\t};\n\t\t\t\treturn walkableData;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\tpublic setStart(start: number | { row: number; col: number }) {\n\t\tthis.start = start;\n\t\treturn this;\n\t}\n\n\tpublic setEnd(end: number | { row: number; col: number }) {\n\t\tthis.end = end;\n\t\treturn this;\n\t}\n\n\tprivate gameMapToPathfind(map: number[][]): AllTypes[][] {\n\t\tconst isStartObject: boolean = typeof this.start === 'number';\n\t\tconst isEndObject: boolean = typeof this.end === 'number';\n\t\treturn map.map((row: number[], rowIndex: number) => {\n\t\t\treturn row.map((id: number, colIndex: number) => {\n\t\t\t\tif (\n\t\t\t\t\t(isStartObject && this.start == id) ||\n\t\t\t\t\t(!isStartObject &&\n\t\t\t\t\t\t(this.start as { row: number; col: number }).row == rowIndex &&\n\t\t\t\t\t\t(this.start as { row: number; col: number }).col == colIndex)\n\t\t\t\t) {\n\t\t\t\t\treturn Types.START;\n\t\t\t\t} else if (\n\t\t\t\t\t(isEndObject && this.end == id) ||\n\t\t\t\t\t(!isEndObject &&\n\t\t\t\t\t\t(this.end as { row: number; col: number }).row == rowIndex &&\n\t\t\t\t\t\t(this.end as { row: number; col: number }).col == colIndex)\n\t\t\t\t) {\n\t\t\t\t\treturn Types.END;\n\t\t\t\t} else if (this.isTileWalkable(id)) {\n\t\t\t\t\tconst item: WalkableTile | number = this.getTileWalkable(id);\n\t\t\t\t\treturn (item as WalkableTile).weight ? (item as WalkableTile).weight : 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn Types.NON_WALKABLE;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate isTileWalkable(mapItem: number) {\n\t\treturn this.walkableTypes.some((type: number | WalkableTile) => {\n\t\t\tif (this.isNumber(type as number)) {\n\t\t\t\treturn (type as number) == mapItem;\n\t\t\t} else {\n\t\t\t\treturn (type as WalkableTile).type == mapItem;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate getTileWalkable(mapItem: number): WalkableTile | number {\n\t\treturn this.walkableTypes.filter((type: number | WalkableTile) => {\n\t\t\tif (this.isNumber(type as number)) {\n\t\t\t\treturn (type as number) === mapItem;\n\t\t\t} else {\n\t\t\t\treturn (type as WalkableTile).type === mapItem;\n\t\t\t}\n\t\t})[0] as WalkableTile | number;\n\t}\n\n\tpublic find(map: number[][]): { col: number; row: number }[] {\n\t\tif (this.start == undefined || this.start == null) {\n\t\t\tthrow new Error(\"There is no start point. Please, use setStart() to configure the path's start point.\");\n\t\t}\n\n\t\tif (this.end == undefined || this.end == null) {\n\t\t\tthrow new Error(\"There is no end point. Please, use setEnd() to configure the path's end point.\");\n\t\t}\n\n\t\tconst finalMap: AllTypes[][] = this.gameMapToPathfind(map);\n\t\tconst firstElement =\n\t\t\ttypeof this.start !== 'number'\n\t\t\t\t? new Node(this.start.row, this.start.col, 0)\n\t\t\t\t: this.findStartElement(finalMap);\n\t\tconst lastElement =\n\t\t\ttypeof this.end !== 'number' ? new Node(this.end.row, this.end.col, 0) : this.findEndElement(finalMap);\n\t\treturn this.findBestPath(firstElement, lastElement, finalMap);\n\t}\n\n\tprivate findStartElement(map: AllTypes[][]): Node {\n\t\tconst startPoint: Node = this.findElement(map, Types.START) as Node;\n\t\tif (startPoint == null) {\n\t\t\tthrow new Error(\"Couldn't find a start point.\");\n\t\t}\n\t\treturn startPoint;\n\t}\n\n\tprivate findEndElement(map: AllTypes[][]): Node {\n\t\tconst endPoint: Node = this.findElement(map, Types.END) as Node;\n\t\tif (endPoint == null) {\n\t\t\tthrow new Error(\"Couldn't find a end point.\");\n\t\t}\n\t\treturn endPoint;\n\t}\n\n\tprivate findElement(map: AllTypes[][], value: AllTypes): Node | null {\n\t\tlet el = null;\n\t\tmap.forEach((element, indexRow) => {\n\t\t\telement.forEach((element, indexCol) => {\n\t\t\t\tif (element == value) {\n\t\t\t\t\tel = new Node(indexRow, indexCol, 0);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\treturn el;\n\t}\n\n\tprivate findBestPath(firstElement: Node, lastElement: Node, map: AllTypes[][]): { col: number; row: number }[] {\n\t\tconst closedList: Node[] = [];\n\t\tconst openList: Node[] = [];\n\t\tlet isFinished: boolean = false;\n\t\tlet lastNode: Node = firstElement;\n\t\tlet lastNodeAdjacents;\n\t\tclosedList.push(firstElement);\n\n\t\twhile (!isFinished) {\n\t\t\tthis.updateLists(map, lastNode, closedList, openList, lastElement);\n\t\t\tif (openList.length > 0) closedList.push(openList.pop() as Node);\n\n\t\t\tlastNode = closedList[closedList.length - 1];\n\n\t\t\tlastNodeAdjacents = this.findAdjacents(map, lastNode).filter(\n\t\t\t\t(elementAdjacent: Node) =>\n\t\t\t\t\tthis.elementNotExistsInside(openList, elementAdjacent) &&\n\t\t\t\t\tthis.elementNotExistsInside(closedList, elementAdjacent),\n\t\t\t);\n\n\t\t\tisFinished =\n\t\t\t\tthis.isNodeEqual(closedList[closedList.length - 1], lastElement) ||\n\t\t\t\t(openList.length == 0 && !lastNodeAdjacents.length);\n\t\t}\n\n\t\treturn openList.length > 0 ? this.getPath(closedList[closedList.length - 1]) : [];\n\t}\n\n\tprivate updateLists(map: AllTypes[][], currentNode: Node, closedList: Node[], openList: Node[], lastElement: Node) {\n\t\t//get all adjacents position possibilities that we don't have in the closed list\n\t\tconst validAdjacents = this.findAdjacents(map, currentNode).filter((elementAdjacent: Node) =>\n\t\t\tthis.elementNotExistsInside(closedList, elementAdjacent),\n\t\t);\n\n\t\t//get all adjacents position possibilities that we have in the open list and don't have inside the closed list\n\t\tconst validAdjacentsOpenList = validAdjacents.filter((elementAdjacent: Node) =>\n\t\t\tthis.elementExistsInside(openList, elementAdjacent),\n\t\t);\n\n\t\t//update distance values if the new potencial Node position on the path is longer than the current one\n\t\tvalidAdjacentsOpenList.forEach((elementAdjacent: Node) => {\n\t\t\tconst validElement = openList.filter((element: Node) => this.isNodeEqual(element, elementAdjacent))[0];\n\t\t\tif (currentNode.getG() + this.getMoveValue(validElement, currentNode) < validElement.getG()) {\n\t\t\t\tvalidElement.setG(this.getMoveValue(validElement, currentNode));\n\t\t\t\tvalidElement.setParent(currentNode);\n\t\t\t}\n\t\t});\n\n\t\t//get all adjacents posiiton possibilities that we don't have in the open list and don't have inside the closed list\n\t\tconst validAdjacentsNewOpenList = validAdjacents.filter((elementAdjacent: Node) =>\n\t\t\tthis.elementNotExistsInside(openList, elementAdjacent),\n\t\t);\n\n\t\t//update distance values for the potencial new positions in the open list\n\t\tvalidAdjacentsNewOpenList.forEach((element) => {\n\t\t\telement.setParent(currentNode);\n\t\t\telement.setH(this.distanceBetweenNodes(element, lastElement));\n\t\t\telement.setG(this.getMoveValue(currentNode, element));\n\t\t\topenList.push(element);\n\t\t});\n\n\t\topenList.sort((a, b) => b.getValue() - a.getValue());\n\t}\n\n\tprivate elementNotExistsInside(list: Node[], element: Node) {\n\t\treturn !this.elementExistsInside(list, element);\n\t}\n\n\tprivate elementExistsInside(list: Node[], element: Node) {\n\t\treturn list.some((el: Node) => {\n\t\t\treturn this.isNodeEqual(el, element);\n\t\t});\n\t}\n\n\tprivate distanceBetweenNodes(initialNode: Node, finalNode: Node) {\n\t\tconst col = Math.abs(finalNode.getCol() - initialNode.getCol());\n\t\tconst row = Math.abs(finalNode.getRow() - initialNode.getRow());\n\n\t\tif (this.heuristic === Heuristic.MANHATTAN) {\n\t\t\treturn this.DEFAULT_DISTANCE * (col + row);\n\t\t} else {\n\t\t\treturn (\n\t\t\t\tthis.DEFAULT_DISTANCE * (col + row) +\n\t\t\t\t(this.DIAGONAL_DISTANCE - 2 * this.DEFAULT_DISTANCE) * Math.min(col, row)\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate getMoveValue(node: Node, newNode: Node) {\n\t\tif (node.getRow() != newNode.getRow() && node.getCol() != newNode.getCol())\n\t\t\treturn this.DIAGONAL_DISTANCE * (1 + newNode.getWeight());\n\t\telse return this.DEFAULT_DISTANCE * (1 + newNode.getWeight());\n\t}\n\n\tprivate findAdjacents(map: AllTypes[][], node: Node): Node[] {\n\t\tconst adjacents: Node[] = [];\n\t\tconst diagonal = [\n\t\t\t[-1, -1],\n\t\t\t[-1, 1],\n\t\t\t[1, -1],\n\t\t\t[1, 1],\n\t\t];\n\t\tconst square = [\n\t\t\t[-1, 0],\n\t\t\t[0, -1],\n\t\t\t[0, 1],\n\t\t\t[1, 0],\n\t\t];\n\n\t\tconst mapElements = map;\n\t\tlet x,\n\t\t\ty = 0;\n\n\t\tfor (let v = 0; v < square.length; v++) {\n\t\t\tx = node.getRow() + square[v][0];\n\t\t\ty = node.getCol() + square[v][1];\n\n\t\t\tif (\n\t\t\t\tx > -1 &&\n\t\t\t\ty > -1 &&\n\t\t\t\tx < mapElements.length &&\n\t\t\t\ty < mapElements[x].length &&\n\t\t\t\t(this.isNumber(mapElements[x][y]) || mapElements[x][y] == Types.END)\n\t\t\t) {\n\t\t\t\tadjacents.push(new Node(x, y, mapElements[x][y] as number));\n\t\t\t}\n\t\t}\n\n\t\tlet addAdjacents = false;\n\n\t\tif (this.heuristic === Heuristic.DIAGONAL) {\n\t\t\tfor (let v = 0; v < diagonal.length; v++) {\n\t\t\t\tx = node.getRow() + diagonal[v][0];\n\t\t\t\ty = node.getCol() + diagonal[v][1];\n\n\t\t\t\tif (\n\t\t\t\t\tx > -1 &&\n\t\t\t\t\ty > -1 &&\n\t\t\t\t\tx < mapElements.length &&\n\t\t\t\t\ty < mapElements[x].length &&\n\t\t\t\t\t(this.isNumber(mapElements[x][y]) || mapElements[x][y] == Types.END)\n\t\t\t\t) {\n\t\t\t\t\tif (!this.allowDiagonal) {\n\t\t\t\t\t\taddAdjacents = false;\n\t\t\t\t\t\tfor (let index = 0; index < diagonal.length; index++) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tindex == v &&\n\t\t\t\t\t\t\t\tthis.isNumber(mapElements[x - diagonal[v][0]][y]) &&\n\t\t\t\t\t\t\t\tthis.isNumber(mapElements[x][y - diagonal[v][1]])\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\taddAdjacents = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (addAdjacents) {\n\t\t\t\t\t\t\tadjacents.push(new Node(x, y, mapElements[x][y] as number));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadjacents.push(new Node(x, y, mapElements[x][y] as number));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn adjacents;\n\t}\n\n\tprivate isNumber(item: AllTypes): boolean {\n\t\treturn Object.prototype.toString.apply(item).indexOf('Number') > -1;\n\t}\n\n\tprivate getPath(node: Node): { col: number; row: number }[] {\n\t\tlet currentNode = node;\n\t\tconst listPath = [];\n\t\twhile (currentNode) {\n\t\t\tlistPath.push(this.nodeToObject(currentNode));\n\t\t\tcurrentNode = currentNode.getParent();\n\t\t}\n\t\treturn listPath.reverse();\n\t}\n\n\tprivate nodeToObject(node: Node) {\n\t\treturn { col: node.getCol(), row: node.getRow() };\n\t}\n\n\tprivate isNodeEqual(element: Node, element0: Node): boolean {\n\t\treturn element.getRow() == element0.getRow() && element.getCol() == element0.getCol();\n\t}\n}\n"]}